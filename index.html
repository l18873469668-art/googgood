  <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI åœ£è¯æ ‘ (å›½å†…åŠ é€Ÿç‰ˆ)</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* --- UI å±‚å¸ƒå±€ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* ç©¿é€ç‚¹å‡» */
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        /* æ ‡é¢˜åŒº */
        .header { text-align: center; margin-top: 10px; }
        .header h1 {
            color: #d4af37; font-size: 24px; margin: 0; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
        }
        .header p { color: #888; font-size: 12px; margin: 5px 0 0; }

        /* çŠ¶æ€é¢æ¿ (HUD) */
        .hud-panel {
            pointer-events: auto; background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; padding: 15px; width: 100%; max-width: 320px;
            align-self: center; margin-bottom: 20px;
        }

        /* çŠ¶æ€æŒ‡ç¤ºç¯ */
        .status-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .status-item {
            font-size: 13px; color: #555; background: rgba(255,255,255,0.05);
            padding: 8px; border-radius: 6px; text-align: center; transition: all 0.3s;
        }
        .status-item.active {
            color: #000; background: #d4af37; font-weight: bold;
            box-shadow: 0 0 10px #d4af37;
        }

        /* æŒ‰é’® */
        .btn-upload {
            background: linear-gradient(90deg, #d4af37, #f2c94c);
            border: none; width: 100%; padding: 12px; border-radius: 25px;
            color: #000; font-weight: bold; font-size: 14px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn-upload:active { transform: scale(0.98); }

        /* --- è§†é¢‘åé¦ˆçª— --- */
        #video-preview {
            position: absolute; top: 10px; right: 10px; width: 100px; height: 75px;
            border-radius: 8px; border: 2px solid rgba(255,255,255,0.2);
            object-fit: cover; transform: scaleX(-1); z-index: 20; opacity: 0; transition: opacity 1s;
        }

        /* --- åŠ è½½é®ç½© --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(212, 175, 55, 0.3);
            border-top-color: #d4af37; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        #loader-text { color: #d4af37; font-size: 14px; letter-spacing: 1px; }
        #error-msg { color: #ff4444; font-size: 13px; margin-top: 10px; max-width: 80%; text-align: center; display: none;}

        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">æ­£åœ¨è¿æ¥å›½å†…é•œåƒæº...</div>
        <div id="error-msg"></div>
    </div>

    <video id="video-preview" playsinline muted></video>

    <div id="ui-layer">
        <div class="header">
            <h1>é­”æ³•åœ£è¯æ ‘</h1>
            <p>Gesture Christmas Tree</p>
        </div>

        <div class="hud-panel">
            <div class="status-grid">
                <div class="status-item" id="status-fist">âœŠ æ¡æ‹³èšåˆ</div>
                <div class="status-item" id="status-open">ğŸ– å¼ å¼€æ•£è½</div>
                <div class="status-item" id="status-pinch">ğŸ¤ æåˆæŠ“å–</div>
                <div class="status-item" id="status-move">ğŸ‘‹ æŒ¥æ‰‹æ—‹è½¬</div>
            </div>
            
            <button class="btn-upload" onclick="document.getElementById('file-input').click()">
                <span>ğŸ“· ä¸Šä¼ ç…§ç‰‡/è‡ªå®šä¹‰è´´å›¾</span>
            </button>
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            <p style="text-align: center; color: rgba(255,255,255,0.4); font-size: 10px; margin: 8px 0 0;">æ¨èä¸Šä¼  5-10 å¼ ç…§ç‰‡</p>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.bootcdn.net/ajax/libs/three.js/0.160.0/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://registry.npmmirror.com/@mediapipe/hands/0.4.1675469240/files/hands.js",
                "@mediapipe/camera_utils": "https://registry.npmmirror.com/@mediapipe/camera_utils/0.3.1675466862/files/camera_utils.js",
                "tween": "https://cdn.bootcdn.net/ajax/libs/tween.js/18.6.4/tween.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Hands } from '@mediapipe/hands';
        import { Camera } from '@mediapipe/camera_utils';
        import TWEEN from 'tween';

        // --- ç³»ç»Ÿé…ç½® ---
        const CONFIG = {
            particleCount: 400, // é™ä½æ•°é‡ä»¥ä¼˜åŒ–æ‰‹æœºæ€§èƒ½
            colors: [0xD4AF37, 0x8B0000, 0x003300, 0xFFFFFF], 
            bloomStrength: 1.0,
            mirrorUrl: "https://registry.npmmirror.com/@mediapipe/hands/0.4.1675469240/files/" // å…³é”®ï¼šMediaPipe èµ„æºé•œåƒ
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer, controls;
        let particles = [];
        let photos = [];
        let currentState = 'tree';
        let handState = 'unknown';
        const loaderEl = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const errorMsg = document.getElementById('error-msg');
        
        // --- 1. åˆå§‹åŒ– 3D åœºæ™¯ ---
        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020202);
                scene.fog = new THREE.FogExp2(0x020202, 0.03);

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 45);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²å¡é¡¿
                container.appendChild(renderer.domElement);

                // ç¯å…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 3);
                scene.add(ambientLight);
                const pLight = new THREE.PointLight(0xD4AF37, 2, 80);
                pLight.position.set(0, 10, 10);
                scene.add(pLight);

                // åå¤„ç† (è¾‰å…‰)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = CONFIG.bloomStrength;
                bloomPass.radius = 0.3;
                bloomPass.threshold = 0.2;

                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.0;

                createParticles();
                
                window.addEventListener('resize', onWindowResize);
                loaderText.innerText = "3D åœºæ™¯å°±ç»ªï¼Œæ­£åœ¨è¿æ¥ AI æ¨¡å‹...";
                
            } catch (e) {
                showError("åˆå§‹åŒ–å¤±è´¥: æ‚¨çš„è®¾å¤‡å¯èƒ½ä¸æ”¯æŒ WebGL");
            }
        }

        // --- 2. ç²’å­ç”Ÿæˆ (ä¼˜åŒ–ç‰ˆ) ---
        function createParticles() {
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            // é»˜è®¤å‡ ä½•ä½“ï¼šæ›´ç²¾è‡´çš„ç¤¼ç‰©ç›’(Box)å’Œè£…é¥°çƒ(Sphere)
            const geoBox = new THREE.BoxGeometry(1, 1, 1);
            const geoSphere = new THREE.SphereGeometry(0.6, 16, 16);
            
            // æè´¨
            const matGold = new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 0.8, roughness: 0.1 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0x8B0000, metalness: 0.3, roughness: 0.4, emissive: 0x220000 });
            const matGlow = new THREE.MeshBasicMaterial({ color: 0xFFFFCC }); // å‘å…‰ç²’å­

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh, type = 'shape';

                // é€»è¾‘ï¼šå¦‚æœæœ‰ç…§ç‰‡ï¼Œä¼˜å…ˆç”¨ç…§ç‰‡ï¼›å¦åˆ™æ··åˆä½¿ç”¨ é‡‘è‰²/çº¢è‰²/å‘å…‰ æè´¨
                if (photos.length > 0 && i % 10 === 0) {
                    const tex = photos[Math.floor(Math.random() * photos.length)];
                    const aspect = tex.image.width / tex.image.height;
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(3 * aspect, 3), new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
                    type = 'photo';
                } else {
                    const rand = Math.random();
                    if (rand > 0.9) mesh = new THREE.Mesh(geoSphere, matGlow); // 10% æ¦‚ç‡ç”Ÿæˆå‘å…‰ç‚¹
                    else if (rand > 0.5) mesh = new THREE.Mesh(geoBox, matGold);
                    else mesh = new THREE.Mesh(geoSphere, matRed);
                }

                // æ ‘å½¢æ€ (åœ†é”¥)
                const y = (Math.random() * 30) - 15;
                const r = (1 - (y + 15) / 30) * 12 + Math.random();
                const theta = Math.random() * Math.PI * 2;
                
                const treePos = { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) };
                
                // æ•£è½å½¢æ€ (å¤§çƒä½“)
                const sR = 15 + Math.random() * 35;
                const sPhi = Math.acos(2 * Math.random() - 1);
                const sTheta = Math.random() * Math.PI * 2;
                const scatterPos = { 
                    x: sR * Math.sin(sPhi) * Math.cos(sTheta), 
                    y: sR * Math.sin(sPhi) * Math.sin(sTheta), 
                    z: sR * Math.cos(sPhi) 
                };

                mesh.position.set(treePos.x, treePos.y, treePos.z);
                mesh.lookAt(0,0,0);
                if(type === 'photo') mesh.rotation.y = Math.random() * 6.28;

                scene.add(mesh);
                particles.push({ mesh, treePos, scatterPos, originalScale: mesh.scale.clone(), type });
            }
        }

        // --- 3. AI åˆå§‹åŒ– (å›½å†…é•œåƒç‰ˆ) ---
        async function initAI() {
            try {
                const videoEl = document.getElementById('video-preview');
                
                const hands = new Hands({
                    // ğŸš€ å…³é”®ï¼šå¼ºåˆ¶æŒ‡å®šå›½å†…é•œåƒè·¯å¾„ï¼Œè§£å†³ locateFile 404 é—®é¢˜
                    locateFile: (file) => {
                        return `${CONFIG.mirrorUrl}${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onAIResults);

                const cameraObj = new Camera(videoEl, {
                    onFrame: async () => {
                        await hands.send({image: videoEl});
                    },
                    width: 640,
                    height: 480
                });

                await cameraObj.start();
                
                // æˆåŠŸå¯åŠ¨
                videoEl.style.opacity = 0.8; // æ˜¾ç¤ºå°çª—
                loaderEl.style.opacity = 0;
                setTimeout(() => loaderEl.style.display = 'none', 500);

            } catch (err) {
                console.error(err);
                if (err.name === 'NotAllowedError') {
                    showError("è¯·å…è®¸è®¿é—®æ‘„åƒå¤´ï¼Œå¦åˆ™æ— æ³•è¯†åˆ«æ‰‹åŠ¿");
                } else {
                    showError("AI æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°é‡è¯•\n(å»ºè®®ä½¿ç”¨æ‰‹æœºçƒ­ç‚¹æˆ– WiFi)");
                }
            }
        }

        // --- 4. æ ¸å¿ƒäº¤äº’é€»è¾‘ ---
        function onAIResults(results) {
            // é‡ç½®çŠ¶æ€æ ·å¼
            document.querySelectorAll('.status-item').forEach(el => el.classList.remove('active'));

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

            const lm = results.multiHandLandmarks[0];
            const state = detectGesture(lm);
            
            // çŠ¶æ€æœºå¤„ç†
            if (state !== handState) {
                handState = state;
                handleStateChange(state);
            }

            // å®æ—¶åé¦ˆï¼šæ‰‹éƒ¨ç§»åŠ¨æ§åˆ¶æ—‹è½¬
            if (currentState === 'scatter' && state === 'open') {
                const handX = lm[9].x; // ä¸­æŒ‡æ ¹éƒ¨ X åæ ‡ (0-1)
                controls.autoRotate = true;
                controls.autoRotateSpeed = (handX - 0.5) * 20; // çµæ•åº¦
                document.getElementById('status-move').classList.add('active');
            }
        }

        function detectGesture(lm) {
            // ç®€å•å‡ ä½•ç®—æ³•
            const wrist = lm[0];
            const tips = [8, 12, 16, 20]; // å››æŒ‡å°–
            
            let extended = 0;
            tips.forEach(t => {
                const dist = Math.sqrt((lm[t].x - wrist.x)**2 + (lm[t].y - wrist.y)**2);
                if (dist > 0.2) extended++; // é˜ˆå€¼å¯è°ƒ
            });

            // æåˆæ£€æµ‹
            const pinchDist = Math.sqrt((lm[4].x - lm[8].x)**2 + (lm[4].y - lm[8].y)**2);
            
            if (pinchDist < 0.05) return 'pinch';
            if (extended <= 1) return 'fist';
            if (extended >= 3) return 'open';
            return 'unknown';
        }

        function handleStateChange(gesture) {
            // UI é«˜äº®
            if(gesture !== 'unknown') {
                const map = {'fist': 'status-fist', 'open': 'status-open', 'pinch': 'status-pinch'};
                if(map[gesture]) document.getElementById(map[gesture]).classList.add('active');
            }

            // 3D å˜æ¢
            if (gesture === 'fist') {
                transformTo('tree');
            } else if (gesture === 'open') {
                transformTo('scatter');
            } else if (gesture === 'pinch' && currentState === 'scatter') {
                zoomPhoto();
            }
        }

        function transformTo(target) {
            if (currentState === target) return;
            currentState = target;
            
            controls.autoRotate = (target === 'tree'); // æ ‘çŠ¶æ€è‡ªåŠ¨æ—‹è½¬

            particles.forEach(p => {
                const pos = target === 'tree' ? p.treePos : p.scatterPos;
                new TWEEN.Tween(p.mesh.position)
                    .to({ x: pos.x, y: pos.y, z: pos.z }, 1500)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
                
                new TWEEN.Tween(p.mesh.rotation)
                    .to({ x: Math.random()*3, y: Math.random()*3 }, 1500)
                    .start();
                
                // æ¢å¤ç¼©æ”¾
                if(target !== 'zoom') {
                    new TWEEN.Tween(p.mesh.scale)
                    .to({ x: p.originalScale.x, y: p.originalScale.y, z: p.originalScale.z }, 500)
                    .start();
                }
            });
        }

        function zoomPhoto() {
            // ç®€å•å®ç°ï¼šéšæœºæŠ“ä¸€å¼ ç…§ç‰‡é£åˆ°çœ¼å‰
            const photoParticles = particles.filter(p => p.type === 'photo');
            if (photoParticles.length === 0) return;
            
            const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
            
            new TWEEN.Tween(target.mesh.position)
                .to({ x: camera.position.x * 0.5, y: camera.position.y * 0.5, z: camera.position.z * 0.5 }, 1000)
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            new TWEEN.Tween(target.mesh.scale)
                .to({ x: 3, y: 3, z: 3 }, 1000)
                .start();
                
            target.mesh.lookAt(camera.position);
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---
        function showError(msg) {
            loaderText.style.display = 'none';
            document.querySelector('.spinner').style.display = 'none';
            errorMsg.style.display = 'block';
            errorMsg.innerText = msg;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            composer.render();
        }

        // ç…§ç‰‡ä¸Šä¼ ç›‘å¬
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;
            photos = [];
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    const tex = new THREE.TextureLoader().load(img.src);
                    tex.colorSpace = THREE.SRGBColorSpace;
                    photos.push(tex);
                    if(photos.length === files.length) createParticles(); // é‡å»ºåœºæ™¯
                };
                reader.readAsDataURL(file);
            });
        });

        // å¯åŠ¨æµç¨‹
        initThree();
        initAI();
        animate();

    </script>
</body>
</html>